# -*- coding: utf-8 -*-
"""CPS manipulation dectection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10YWy2Y0SzzMDZ2R-DV_-9BaWsASpWMPU
"""
#Plot bar charts to display scheduled pricing curves 
def plot(model, count, cost):
    hours = [str(x) for x in range(0, 24)]
    pos = np.arange(len(hours))
    users = ['user1', 'user2', 'user3', 'user4', 'user5']
    colors = ['red','green','blue','orange','yellow']
    plot_list = []
    to_plot = []
    
    #Store usage for each hour in a list
    for user in users:
        temp_list = []
        for hour in hours:
            hour_list_temp = []
            task_count = 0
            for var in model.variables():
                if user == var.name.split('_')[0] and str(hour) == var.name.split('_')[2]:
                    task_count += 1
                    hour_list_temp.append(var.value())
            temp_list.append(sum(hour_list_temp))
        plot_list.append(temp_list)

    #Stack users as bars
    plt.bar(pos,plot_list[0],color=colors[0],edgecolor='black',bottom=0)
    plt.bar(pos,plot_list[1],color=colors[1],edgecolor='black',bottom=np.array(plot_list[0]))
    plt.bar(pos,plot_list[2],color=colors[2],edgecolor='black',bottom=np.array(plot_list[0])+np.array(plot_list[1]))
    plt.bar(pos,plot_list[3],color=colors[3],edgecolor='black',bottom=np.array(plot_list[0])+np.array(plot_list[1])+np.array(plot_list[2]))
    plt.bar(pos,plot_list[4],color=colors[4],edgecolor='black',bottom=np.array(plot_list[0])+np.array(plot_list[1])+np.array(plot_list[2])+np.array(plot_list[3]))
    plt.xticks(pos, hours)
    plt.xlabel('Hour')
    plt.ylabel('Energy Usage (kW)')
    plt.title('Energy Usage Per Hour For All Users\nDay %i\nMinimized Cost = %.15f'%(count ,cost))
    plt.legend(users,loc=0)
    fig = plt.gcf()
    fig.savefig('/plots/'+str(count)+'.png')
    plt.show()
    plt.clf()
    

    return plot_list
#mout drive to work with colab
# from google.colab import drive
# drive.mount('/content/drive/')

#Install PuLP
# !pip install pulp

#Import required libraries
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn import metrics
from sklearn import linear_model
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
import pandas as pd
from pulp import *
import matplotlib.pyplot as plt

#Read Training and Testing data
trainDF = pd.read_csv('/TrainingData.txt', header=None)
y = trainDF[24].tolist()
trainDF = trainDF.drop(24, axis=1)
x = trainDF.values.tolist()
testDF = pd.read_csv('/TestingData.txt', header=None)
x_classify = testDF.values.tolist()

#Split Full data into Test and Training for local testing using 20% for test
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=0)
print(len(x_train),len(x_test),len(y_train),len(y_test))

#Use the LDA model and train it with your data and perform local testing
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
lda = LinearDiscriminantAnalysis()
lda.fit(x_train, y_train)
y_pred = lda.predict(x_test)
print(len(y_pred))
print("Testing accuracy:",lda.score(x_test, y_test))
print("Training accuracy:",lda.score(x, y))

#Classify the given Testing data and get labels
y_classify_pred = lda.predict(x_classify)
y_classify_pred = [int(i) for i in y_classify_pred]
predDF = pd.DataFrame({'Prediction': y_classify_pred})
testDF = testDF.join(predDF)
testDF.to_csv("/TestingResults.txt", header=None, index=None)
predDF.to_csv("/PredictionsOnly.txt", header=None, index=None)
print("Predictions Saved")
for i in range(0,100):
  print("DAY => "+str(i+1)+"\tPrediction => "+str(y_classify_pred[i]) )

#
# SVM MODEL
#
# from sklearn import svm
# from sklearn.svm import SVC
# from sklearn.metrics import classification_report, confusion_matrix
# svclassifier = SVC(kernel='linear')
# svclassifier.fit(x_train,y_train)
# y_pred = svclassifier.predict(x_test)
# print(classification_report(y_test,y_pred))
# print("Accuracy:", metrics.accuracy_score(y_test,y_pred))
# y_classify_pred = svclassifier.predict(x_classify)
# y_classify_pred = [int(i) for i in y_classify_pred]
# predDF = pd.DataFrame({'Prediction': y_classify_pred})
# testDF = testDF.join(predDF)
# testDF.to_csv("/content/drive/MyDrive/COMP321720212022CW2A/TestingResultsSVM.txt", header=None, index=None)
# predDF.to_csv("PredictionsOnlySVM.txt", header=None, index=None)
# print("\nPredictions in output file TestingResultsSVM.txt")

#
# KNN MODEL
#
# from sklearn.neighbors import KNeighborsClassifier
# model = KNeighborsClassifier(n_neighbors=50)
# model.fit(x_train,y_train)
# predicted= model.predict(x_test)
# print(predicted)
# print(confusion_matrix(y_test,predicted))
# print(classification_report(y_test,predicted))
# print("Accuracy:", metrics.accuracy_score(y_test,predicted))

#Read task data from User & Task ID sheet
input = pd.read_excel ('/COMP3217CW2Input.xlsx', sheet_name = 'User & Task ID')
taskName = input['User & Task ID'].tolist()
readyTime = input['Ready Time'].tolist()
deadline = input['Deadline'].tolist()
maxEnergyPerHour = input['Maximum scheduled energy per hour'].tolist()
energyDemand = input['Energy Demand'].tolist()
tasks = []
taskNames = []

#Store Tasks in a list of lists
for i in range (len(readyTime)):
    task = []
    task.append(readyTime[i])
    task.append(deadline[i])
    task.append(maxEnergyPerHour[i])
    task.append(energyDemand[i])
    taskNames.append(taskName[i])
    tasks.append(task)
          
#Reading Testing Data Output
testDF = pd.read_csv('/TestingResults.txt', header=None)
y_results = testDF[24].tolist()
testDF = testDF.drop(24, axis=1)
x_data = testDF.values.tolist()

#Read the abnormal pricing guide for scheduling prices
abnormal_price_list = pd.read_excel ('/COMP3217CW2Input.xlsx', sheet_name = 'AbnormalGuidelinePricing')
abnormal_price_list = abnormal_price_list['Unit Cost'].tolist()
print(abnormal_price_list)

# Compute Linear problem and solve it
answerlist=[]
for index, price_list in enumerate(x_data):
  if y_results[index] == 1:
    vars = []
    c = []
    eq = []
    
    #Generate min LpProblem   
    model = LpProblem(name="scheduling-problem", sense=LpMinimize)
    
    #Loop through tasks to create the LpProblem
    for ind, task in enumerate(tasks):
        n = task[1] - task[0] + 1
        temp = []
        for i in range(task[0], task[1] + 1):
            x = LpVariable(name=taskNames[ind]+'_'+str(i), lowBound=0, upBound=task[2])
            temp.append(x)
        vars.append(temp)
        for var in vars[ind]:
            price = abnormal_price_list[int(var.name.split('_')[2])]
            c.append(price * var)
    model += lpSum(c)
                
    #Add constraints on which minimization should happen    
    for i, task in enumerate(tasks):
        temp = []
        for var in vars[i]:
            temp.append(var)
        eq.append(temp)
        model += lpSum(temp) == task[3]
      
    #Solve the LpProblem
    answer = model.solve()
    answerlist.append(answer)
    print(LpStatus[answer], value(model.objective))
    
    #Plot bar charts
    plot(model,index+1,value(model.objective))
      
print(len(answerlist))

